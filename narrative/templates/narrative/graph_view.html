{% extends "base.html" %}
{% load narrative_tags %}

{% block title %}{{ graph_title|default:"Narrative Graph" }}{% endblock %}

{% block extra_css %}
<style>
    /* Full-screen graph container */
    #graph-container {
        position: fixed;
        top: 64px;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, #0a0a0f 0%, #0f172a 100%);
    }

    /* Stats badge - top left */
    .graph-stats {
        position: absolute;
        top: 88px;
        left: 24px;
        background: rgba(15, 23, 42, 0.95);
        border: 1px solid rgba(51, 65, 85, 0.5);
        border-radius: 12px;
        padding: 16px 20px;
        backdrop-filter: blur(16px);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        z-index: 10;
    }

    /* Controls - top right */
    .graph-controls {
        position: absolute;
        top: 88px;
        right: 24px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 10;
    }

    .graph-control-btn {
        width: 48px;
        height: 48px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(15, 23, 42, 0.95);
        border: 1px solid rgba(51, 65, 85, 0.5);
        border-radius: 12px;
        color: rgb(148, 163, 184);
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        backdrop-filter: blur(12px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .graph-control-btn:hover {
        background: rgba(51, 65, 85, 0.8);
        color: white;
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        border-color: rgba(245, 158, 11, 0.3);
    }

    .graph-control-btn:active {
        transform: translateY(0);
    }

    .graph-control-btn.active {
        background: rgba(245, 158, 11, 0.2);
        border-color: rgba(245, 158, 11, 0.5);
        color: rgb(245, 158, 11);
    }

    /* Node type toggle buttons */
    .node-toggle {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 4px 10px;
        font-size: 11px;
        font-weight: 500;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
        border: 1px solid transparent;
        background: rgba(30, 41, 59, 0.6);
        color: rgba(148, 163, 184, 0.6);
    }

    .node-toggle.active {
        background: color-mix(in srgb, var(--toggle-color) 20%, transparent);
        border-color: color-mix(in srgb, var(--toggle-color) 50%, transparent);
        color: var(--toggle-color);
    }

    .node-toggle:hover {
        background: color-mix(in srgb, var(--toggle-color) 30%, transparent);
        color: var(--toggle-color);
    }

    /* Legend - bottom left */
    .graph-legend {
        position: absolute;
        bottom: 24px;
        left: 24px;
        background: rgba(15, 23, 42, 0.95);
        border: 1px solid rgba(51, 65, 85, 0.5);
        border-radius: 16px;
        padding: 20px;
        backdrop-filter: blur(16px);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        min-width: 280px;
        z-index: 10;
    }

    /* Tooltip - follows mouse cursor */
    .graph-tooltip {
        position: fixed;
        background: rgba(15, 23, 42, 0.97);
        border: 1px solid rgba(51, 65, 85, 0.5);
        border-radius: 14px;
        padding: 16px 18px;
        backdrop-filter: blur(16px);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        max-width: 340px;
        min-width: 200px;
        z-index: 100;
        opacity: 0;
        pointer-events: none;
        transform: translate(16px, 16px);
        transition: opacity 0.15s ease-out;
    }

    .graph-tooltip.visible {
        opacity: 1;
        pointer-events: auto;
    }

    /* Node tooltip styling - color set dynamically via --node-color */
    .graph-tooltip.node-tooltip {
        border-color: color-mix(in srgb, var(--node-color, #f59e0b) 50%, transparent);
        box-shadow: 0 8px 32px color-mix(in srgb, var(--node-color, #f59e0b) 25%, transparent);
    }

    .graph-tooltip.node-tooltip .tooltip-icon-wrapper {
        background: color-mix(in srgb, var(--node-color, #f59e0b) 15%, transparent);
    }

    .graph-tooltip.node-tooltip .tooltip-icon-wrapper i {
        color: var(--node-color, #f59e0b);
    }

    .graph-tooltip.node-tooltip .tooltip-link {
        color: var(--node-color, #f59e0b);
    }

    .graph-tooltip.node-tooltip .tooltip-link:hover {
        background: color-mix(in srgb, var(--node-color, #f59e0b) 20%, transparent);
    }

    /* Edge tooltip link styling */
    .graph-tooltip.edge-tooltip .tooltip-link {
        color: var(--edge-color, #94a3b8);
        background: color-mix(in srgb, var(--edge-color, #94a3b8) 10%, transparent);
    }

    .graph-tooltip.edge-tooltip .tooltip-link:hover {
        background: color-mix(in srgb, var(--edge-color, #94a3b8) 20%, transparent);
    }

    /* Edge tooltip styling - uses connection type color */
    .graph-tooltip.edge-tooltip {
        border-color: var(--edge-color, rgba(51, 65, 85, 0.5));
        box-shadow: 0 8px 32px color-mix(in srgb, var(--edge-color, #334155) 20%, transparent);
    }

    /* Connection type badge in tooltip */
    .conn-type-badge {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 12px;
        border-radius: 8px;
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        background-color: color-mix(in srgb, var(--conn-color) 15%, transparent);
        border: 1px solid color-mix(in srgb, var(--conn-color) 40%, transparent);
        color: var(--conn-color);
    }

    /* Hide node/edge sections based on tooltip type */
    .graph-tooltip.node-tooltip .edge-info { display: none; }
    .graph-tooltip.edge-tooltip .node-info { display: none; }
    .graph-tooltip:not(.node-tooltip):not(.edge-tooltip) .node-info,
    .graph-tooltip:not(.node-tooltip):not(.edge-tooltip) .edge-info { display: none; }

    /* Loading overlay */
    .graph-loading {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: rgba(10, 10, 15, 0.9);
        z-index: 100;
        transition: opacity 0.5s ease-out;
    }

    .graph-loading.hidden {
        opacity: 0;
        pointer-events: none;
    }

    .graph-loading-spinner {
        width: 48px;
        height: 48px;
        border: 3px solid rgba(245, 158, 11, 0.2);
        border-top-color: rgb(245, 158, 11);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        to { transform: rotate(360deg); }
    }
</style>
{% endblock %}

{% block header_actions %}
{% if back_url %}
<a href="{{ back_url }}"
   class="px-4 py-2 text-sm font-medium rounded-lg bg-slate-800/80 text-slate-300 border border-slate-700/50 hover:bg-slate-700 hover:text-white transition-all duration-200">
    <span class="flex items-center gap-2">
        <i data-lucide="chevron-left" class="w-4 h-4"></i>
        Back
    </span>
</a>
{% endif %}
<a href="#" onclick="toggleFullscreen(); return false;"
   class="px-4 py-2 text-sm font-medium rounded-lg bg-slate-800/80 text-slate-300 border border-slate-700/50 hover:bg-slate-700 hover:text-white transition-all duration-200">
    <span class="flex items-center gap-2">
        <i data-lucide="maximize-2" class="w-4 h-4"></i>
    </span>
</a>
<a href="{% url 'wagtail_serve' '' %}"
   class="px-4 py-2 text-sm font-medium rounded-lg bg-amber-500/20 text-amber-400 border border-amber-500/40 shadow-lg shadow-amber-500/10 transition-all duration-200 hover:bg-amber-500/30">
    <span class="flex items-center gap-2">
        <i data-lucide="x" class="w-4 h-4"></i>
        Close Graph
    </span>
</a>
{% endblock %}

{% block content %}
<div id="graph-container"></div>

{# Loading overlay #}
<div id="graph-loading" class="graph-loading">
    <div class="graph-loading-spinner mb-4"></div>
    <div class="text-slate-400 text-sm">Initializing 3D graph...</div>
</div>

{# Stats Badge with Node Type Toggles #}
<div class="graph-stats">
    <div class="flex items-center gap-2 mb-3">
        <i data-lucide="activity" class="w-4 h-4 text-amber-400"></i>
        <div class="text-xs font-bold text-slate-400 uppercase tracking-wider">{{ graph_title|default:"Graph" }}</div>
    </div>
    <div class="flex items-center gap-4 mb-3">
        <div class="text-center">
            <div id="node-count" class="text-xl font-bold text-white">-</div>
            <div class="text-xs text-slate-500">Nodes</div>
        </div>
        <div class="w-px h-8 bg-slate-700/50"></div>
        <div class="text-center">
            <div id="edge-count" class="text-xl font-bold text-white">-</div>
            <div class="text-xs text-slate-500">Edges</div>
        </div>
    </div>
    <div class="border-t border-slate-700/50 pt-3">
        <div class="text-xs text-slate-500 mb-2">Show/Hide:</div>
        <div class="flex flex-wrap gap-2">
            <button class="node-toggle active" data-type="event" style="--toggle-color: #f59e0b;">
                <i data-lucide="zap" class="w-3 h-3"></i> Events
            </button>
            <button class="node-toggle active" data-type="character" style="--toggle-color: #14b8a6;">
                <i data-lucide="user" class="w-3 h-3"></i> Characters
            </button>
            <button class="node-toggle active" data-type="location" style="--toggle-color: #84cc16;">
                <i data-lucide="map-pin" class="w-3 h-3"></i> Locations
            </button>
            <button class="node-toggle active" data-type="organization" style="--toggle-color: #a855f7;">
                <i data-lucide="building-2" class="w-3 h-3"></i> Orgs
            </button>
        </div>
    </div>
</div>

{# Controls #}
<div class="graph-controls">
    <button class="graph-control-btn" id="btn-zoom-in" title="Zoom in">
        <i data-lucide="zoom-in" class="w-5 h-5"></i>
    </button>
    <button class="graph-control-btn" id="btn-zoom-out" title="Zoom out">
        <i data-lucide="zoom-out" class="w-5 h-5"></i>
    </button>
    <button class="graph-control-btn" id="btn-center" title="Center view">
        <i data-lucide="maximize" class="w-5 h-5"></i>
    </button>
    <div class="h-2"></div>
    <button class="graph-control-btn" id="btn-pause" title="Pause/Resume physics">
        <i data-lucide="pause" class="w-5 h-5"></i>
    </button>
    <button class="graph-control-btn" id="btn-toggle-2d" title="Toggle 2D/3D view">
        <i data-lucide="box" class="w-5 h-5"></i>
    </button>
    <div class="h-2"></div>
    <button class="graph-control-btn" id="btn-performance" title="Toggle performance mode">
        <i data-lucide="gauge" class="w-5 h-5"></i>
    </button>
</div>

{# Legend #}
<div class="graph-legend">
    {# Node types #}
    <div class="flex items-center gap-2 mb-3">
        <i data-lucide="circle" class="w-4 h-4 text-amber-400"></i>
        <div class="text-xs font-bold text-slate-400 uppercase tracking-wider">Node Types</div>
    </div>
    <div class="grid grid-cols-2 gap-x-4 gap-y-2 mb-4">
        <div class="flex items-center gap-2">
            <div class="w-3 h-3 rounded-full" style="background-color: #f59e0b; box-shadow: 0 0 8px #f59e0b;"></div>
            <span class="text-xs text-slate-300">Event</span>
        </div>
        <div class="flex items-center gap-2">
            <div class="w-3 h-3 rounded-full" style="background-color: #14b8a6; box-shadow: 0 0 8px #14b8a6;"></div>
            <span class="text-xs text-slate-300">Character</span>
        </div>
        <div class="flex items-center gap-2">
            <div class="w-3 h-3 rounded-full" style="background-color: #84cc16; box-shadow: 0 0 8px #84cc16;"></div>
            <span class="text-xs text-slate-300">Location</span>
        </div>
        <div class="flex items-center gap-2">
            <div class="w-3 h-3 rounded-full" style="background-color: #a855f7; box-shadow: 0 0 8px #a855f7;"></div>
            <span class="text-xs text-slate-300">Organization</span>
        </div>
    </div>

    {# Edge types - participation #}
    <div class="flex items-center gap-2 mb-3 pt-3 border-t border-slate-800/50">
        <i data-lucide="git-branch" class="w-4 h-4 text-teal-400"></i>
        <div class="text-xs font-bold text-slate-400 uppercase tracking-wider">Relationships</div>
    </div>
    <div class="grid grid-cols-2 gap-x-4 gap-y-2 mb-4">
        <div class="flex items-center gap-2">
            <div class="w-5 h-0.5 rounded-full" style="background-color: #14b8a6; box-shadow: 0 0 6px #14b8a6;"></div>
            <span class="text-xs text-slate-300">Participates</span>
        </div>
        <div class="flex items-center gap-2">
            <div class="w-5 h-0.5 rounded-full" style="background-color: #84cc16; box-shadow: 0 0 6px #84cc16;"></div>
            <span class="text-xs text-slate-300">In Event</span>
        </div>
        <div class="flex items-center gap-2">
            <div class="w-5 h-0.5 rounded-full" style="background-color: #a855f7; box-shadow: 0 0 6px #a855f7;"></div>
            <span class="text-xs text-slate-300">Involved</span>
        </div>
        <div class="flex items-center gap-2">
            <div class="w-5 h-0.5 rounded-full" style="background-color: #22d3ee; box-shadow: 0 0 6px #22d3ee;"></div>
            <span class="text-xs text-slate-300">Narrative</span>
        </div>
    </div>

    <div class="mt-4 pt-3 border-t border-slate-800/50 space-y-1.5">
        <div class="flex items-center gap-2 text-xs text-slate-500">
            <i data-lucide="mouse-pointer" class="w-3 h-3"></i>
            <span>Hover for details, click link to navigate</span>
        </div>
        <div class="flex items-center gap-2 text-xs text-slate-500">
            <i data-lucide="move-3d" class="w-3 h-3"></i>
            <span>Drag to rotate, scroll to zoom</span>
        </div>
    </div>
</div>

{# Tooltip #}
<div id="graph-tooltip" class="graph-tooltip">
    {# Node tooltip content #}
    <div class="node-info">
        <div class="flex items-start gap-3 mb-3">
            <div id="tooltip-node-icon" class="tooltip-icon-wrapper w-10 h-10 rounded-lg flex items-center justify-center flex-shrink-0">
                <i data-lucide="zap" class="w-5 h-5"></i>
            </div>
            <div class="flex-1 min-w-0">
                <div id="tooltip-node-type" class="text-[10px] font-bold uppercase tracking-wider text-slate-500 mb-0.5"></div>
                <div id="tooltip-node-title" class="font-semibold text-white leading-tight"></div>
                <div id="tooltip-node-episode" class="text-sm text-slate-400 mt-1"></div>
            </div>
        </div>
        <a id="tooltip-node-link" href="#" class="tooltip-link flex items-center gap-2 text-xs font-medium px-3 py-2 rounded-lg transition-colors mt-2">
            <i data-lucide="external-link" class="w-3.5 h-3.5"></i>
            <span id="tooltip-node-link-text">View details</span>
        </a>
    </div>

    {# Edge tooltip content #}
    <div class="edge-info">
        <div id="tooltip-edge-type" class="conn-type-badge mb-3"></div>
        <div id="tooltip-edge-description" class="text-sm text-slate-300 mb-3 leading-relaxed italic"></div>
        <div class="flex items-center gap-2 text-xs text-slate-500 mb-3 flex-wrap">
            <span id="tooltip-edge-from" class="text-slate-300"></span>
            <i data-lucide="arrow-right" class="w-3 h-3 flex-shrink-0"></i>
            <span id="tooltip-edge-to" class="text-slate-300"></span>
        </div>
        <div id="tooltip-edge-strength" class="text-xs text-slate-500 mb-3"></div>
        <a id="tooltip-edge-link" href="#" class="tooltip-link flex items-center gap-2 text-xs font-medium px-3 py-2 rounded-lg transition-colors">
            <i data-lucide="external-link" class="w-3.5 h-3.5"></i>
            <span>View connection</span>
        </a>
    </div>
</div>
{% endblock %}

{% block extra_js %}
{# 3d-force-graph via CDN (includes Three.js) #}
<script src="https://unpkg.com/3d-force-graph@1.73.3/dist/3d-force-graph.min.js"></script>

<script>
// Graph data from Django
const graphData = {{ graph_data|safe }};
console.log('Graph data loaded:', graphData.nodes.length, 'nodes,', graphData.edges.length, 'edges');
console.log('Sample nodes:', graphData.nodes.slice(0, 3));

// Node type configuration
const NODE_TYPE_CONFIG = {
    'event': { color: '#f59e0b', icon: 'zap', label: 'Event', size: 6 },
    'character': { color: '#14b8a6', icon: 'user', label: 'Character', size: 4 },
    'location': { color: '#84cc16', icon: 'map-pin', label: 'Location', size: 4 },
    'organization': { color: '#a855f7', icon: 'building-2', label: 'Organization', size: 4 }
};

// Graph Gravity tier configuration for character nodes
// Size multipliers are dramatically different for visual distinction
const TIER_CONFIG = {
    'anchor': { sizeMultiplier: 4.0, color: '#fbbf24', icon: 'â˜€ï¸', label: 'Main Cast' },   // â˜€ï¸ SUNs are HUGE
    'planet': { sizeMultiplier: 1.8, color: '#14b8a6', icon: 'ðŸª', label: 'Recurring' },   // ðŸª Planets visible
    'asteroid': { sizeMultiplier: 0.6, color: '#6b7280', icon: 'â˜„ï¸', label: 'One-off' }    // â˜„ï¸ Asteroids tiny
};

// Edge type configuration - real LPG relationships
const CONNECTION_CONFIG = {
    // Participation edges (Entity â†’ Event)
    'PARTICIPATED_AS': { color: '#14b8a6', icon: 'user', label: 'Participates', category: 'participation' },
    'IN_EVENT': { color: '#84cc16', icon: 'map-pin', label: 'In Event', category: 'participation' },
    'INVOLVED_WITH': { color: '#a855f7', icon: 'building-2', label: 'Involved', category: 'participation' },

    // Narrative connections (Event â†’ Event)
    'CAUSAL': { color: '#22d3ee', icon: 'arrow-right', label: 'Causal', category: 'narrative' },
    'FORESHADOWING': { color: '#a855f7', icon: 'sparkles', label: 'Foreshadowing', category: 'narrative' },
    'THEMATIC_PARALLEL': { color: '#f59e0b', icon: 'git-merge', label: 'Thematic Parallel', category: 'narrative' },
    'CHARACTER_CONTINUITY': { color: '#10b981', icon: 'rotate-ccw', label: 'Character Continuity', category: 'narrative' },
    'ESCALATION': { color: '#ef4444', icon: 'trending-up', label: 'Escalation', category: 'narrative' },
    'CALLBACK': { color: '#3b82f6', icon: 'arrow-left', label: 'Callback', category: 'narrative' },
    'EMOTIONAL_ECHO': { color: '#ec4899', icon: 'heart', label: 'Emotional Echo', category: 'narrative' },
    'SYMBOLIC_PARALLEL': { color: '#8b5cf6', icon: 'equal', label: 'Symbolic Parallel', category: 'narrative' },
    'TEMPORAL': { color: '#6366f1', icon: 'clock', label: 'Temporal', category: 'narrative' },
    'NARRATIVELY_FOLLOWS': { color: '#94a3b8', icon: 'arrow-down', label: 'Narratively Follows', category: 'narrative' }
};

// Node type visibility state
const visibleNodeTypes = new Set(['event', 'character', 'location', 'organization']);

// Transform data for 3d-force-graph (uses 'source'/'target' not 'from'/'to')
const allNodes = graphData.nodes.map(n => ({
    ...n,
    connections: 0,
    visible: true
}));

const allLinks = graphData.edges.map(e => ({
    source: e.from,
    target: e.to,
    type: e.type,
    label: e.label,
    strength: e.strength,
    description: e.description || '',
    pk: e.pk,
    color: CONNECTION_CONFIG[e.type]?.color || '#64748b'
}));

// Count connections per node
const nodeMap = new Map(allNodes.map(n => [n.id, n]));
allLinks.forEach(link => {
    const sourceNode = nodeMap.get(link.source);
    const targetNode = nodeMap.get(link.target);
    if (sourceNode) sourceNode.connections++;
    if (targetNode) targetNode.connections++;
});

// Function to get filtered graph data
function getFilteredGraphData() {
    const visibleNodes = allNodes.filter(n => visibleNodeTypes.has(n.nodeType));
    const visibleNodeIds = new Set(visibleNodes.map(n => n.id));
    const visibleLinks = allLinks.filter(l => {
        const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
        const targetId = typeof l.target === 'object' ? l.target.id : l.target;
        return visibleNodeIds.has(sourceId) && visibleNodeIds.has(targetId);
    });
    return { nodes: visibleNodes, links: visibleLinks };
}

// Initial filtered data
let forceGraphData = getFilteredGraphData();

// Check if pre-computed positions are available (from compute_graph_positions command)
const hasPrecomputedPositions = allNodes.some(n => n.x !== null && n.x !== undefined);

// Update stats display
function updateStats() {
    const data = getFilteredGraphData();
    document.getElementById('node-count').textContent = data.nodes.length;
    document.getElementById('edge-count').textContent = data.links.length;
}
updateStats();

// DOM elements
const container = document.getElementById('graph-container');
const loadingOverlay = document.getElementById('graph-loading');
const tooltip = document.getElementById('graph-tooltip');

// Tooltip elements - nodes
const tooltipNodeIcon = document.getElementById('tooltip-node-icon');
const tooltipNodeType = document.getElementById('tooltip-node-type');
const tooltipNodeTitle = document.getElementById('tooltip-node-title');
const tooltipNodeEpisode = document.getElementById('tooltip-node-episode');
const tooltipNodeLink = document.getElementById('tooltip-node-link');
const tooltipNodeLinkText = document.getElementById('tooltip-node-link-text');

// Tooltip elements - edges
const tooltipEdgeType = document.getElementById('tooltip-edge-type');
const tooltipEdgeDescription = document.getElementById('tooltip-edge-description');
const tooltipEdgeFrom = document.getElementById('tooltip-edge-from');
const tooltipEdgeTo = document.getElementById('tooltip-edge-to');
const tooltipEdgeStrength = document.getElementById('tooltip-edge-strength');
const tooltipEdgeLink = document.getElementById('tooltip-edge-link');

// Mouse position tracking
let mouseX = 0;
let mouseY = 0;
let hideTooltipTimeout = null;
let isMouseOverTooltip = false;

document.addEventListener('mousemove', (e) => {
    mouseX = e.clientX;
    mouseY = e.clientY;

    // Update tooltip position if visible
    if (tooltip.classList.contains('visible')) {
        positionTooltip();
    }
});

// Keep tooltip visible when mouse enters it
tooltip.addEventListener('mouseenter', () => {
    isMouseOverTooltip = true;
    if (hideTooltipTimeout) {
        clearTimeout(hideTooltipTimeout);
        hideTooltipTimeout = null;
    }
});

tooltip.addEventListener('mouseleave', () => {
    isMouseOverTooltip = false;
    // Small delay before hiding to allow re-entry
    scheduleHideTooltip(150);
});

function positionTooltip() {
    const tooltipRect = tooltip.getBoundingClientRect();
    const padding = 20;

    // Calculate position - prefer bottom-right of cursor
    let left = mouseX + padding;
    let top = mouseY + padding;

    // Flip to left if would overflow right edge
    if (left + tooltipRect.width > window.innerWidth - padding) {
        left = mouseX - tooltipRect.width - padding;
    }

    // Flip to top if would overflow bottom edge
    if (top + tooltipRect.height > window.innerHeight - padding) {
        top = mouseY - tooltipRect.height - padding;
    }

    // Ensure doesn't go off top or left
    left = Math.max(padding, left);
    top = Math.max(padding, top);

    tooltip.style.left = left + 'px';
    tooltip.style.top = top + 'px';
}

// State
let isPaused = false;
let is3D = true;

// Initialize 3d-force-graph
const Graph = ForceGraph3D()(container)
    .graphData(forceGraphData)
    .backgroundColor('rgba(0,0,0,0)')  // Transparent - CSS handles background

    // Node configuration
    .nodeLabel(null)  // We use custom tooltip
    .nodeColor(node => {
        // Characters use tier-based colors
        if (node.nodeType === 'character' && node.tier) {
            const tierConfig = TIER_CONFIG[node.tier];
            if (tierConfig) return tierConfig.color;
        }
        const config = NODE_TYPE_CONFIG[node.nodeType] || { color: '#64748b' };
        return config.color;
    })
    .nodeVal(node => {
        const config = NODE_TYPE_CONFIG[node.nodeType] || { size: 4 };
        let baseSize = config.size;

        // Characters get tier-based size multiplier
        if (node.nodeType === 'character' && node.tier) {
            const tierConfig = TIER_CONFIG[node.tier];
            if (tierConfig) {
                baseSize = config.size * tierConfig.sizeMultiplier;
            }
        }

        // Events are larger, entities scale with connections
        return node.nodeType === 'event'
            ? baseSize + node.connections * 0.5
            : baseSize + node.connections * 0.3;
    })
    .nodeOpacity(0.9)
    // Adaptive resolution based on graph size
    .nodeResolution(forceGraphData.nodes.length > 300 ? 8 : 16)

    // Link configuration - adaptive for performance
    .linkColor(link => link.color)
    .linkWidth(link => {
        // Thinner lines for large graphs
        const scale = forceGraphData.links.length > 1000 ? 0.6 : 1;
        switch(link.strength) {
            case 'strong': return 2 * scale;
            case 'medium': return 1.2 * scale;
            default: return 0.6 * scale;
        }
    })
    .linkOpacity(forceGraphData.links.length > 1000 ? 0.5 : 0.7)
    // Arrows - color must match link color explicitly
    .linkDirectionalArrowLength(forceGraphData.links.length > 500 ? 0 : 4)
    .linkDirectionalArrowRelPos(1)
    .linkDirectionalArrowColor(link => link.color)  // Fix: arrows inherit link color
    // Straight lines for large graphs (faster)
    .linkCurvature(forceGraphData.links.length > 1000 ? 0 : 0.1)
    // Pulsing particles for small graphs (eye candy but expensive)
    .linkDirectionalParticles(link => {
        if (forceGraphData.links.length > 300) return 0;  // Disable for large graphs
        return link.strength === 'strong' ? 2 : 1;
    })
    .linkDirectionalParticleWidth(2)
    .linkDirectionalParticleSpeed(0.008)
    .linkDirectionalParticleColor(link => link.color)  // Particles match link color

    // Node hover
    .onNodeHover(node => {
        container.style.cursor = node ? 'pointer' : 'default';

        if (node) {
            cancelHideTooltip();
            showNodeTooltip(node);
        } else if (!tooltip.classList.contains('edge-tooltip')) {
            scheduleHideTooltip(200);
        }
    })

    // Node click - navigate to event page
    .onNodeClick(node => {
        if (node && node.url) {
            window.location.href = node.url;
        }
    })

    // Link hover
    .onLinkHover(link => {
        container.style.cursor = link ? 'pointer' : 'default';

        if (link) {
            cancelHideTooltip();
            showEdgeTooltip(link);
        } else if (!tooltip.classList.contains('node-tooltip')) {
            scheduleHideTooltip(200);
        }
    })

    // Link click - navigate to connection detail page
    .onLinkClick(link => {
        if (link && link.pk) {
            window.location.href = `/connections/${link.pk}/`;
        }
    })

    // Performance optimizations - adaptive based on graph size and pre-computed positions
    // When positions are pre-computed, use fewer warmup ticks since layout is already meaningful
    .warmupTicks(hasPrecomputedPositions ? 20 : (forceGraphData.nodes.length > 300 ? 50 : 100))
    .cooldownTicks(hasPrecomputedPositions ? 50 : (forceGraphData.nodes.length > 300 ? 100 : 200))
    .d3AlphaDecay(forceGraphData.nodes.length > 300 ? 0.04 : 0.02)
    .d3VelocityDecay(forceGraphData.nodes.length > 300 ? 0.4 : 0.3)
    // Enable octree for spatial indexing (O(n log n) vs O(nÂ²))
    .d3AlphaMin(0.001)
    .enableNodeDrag(true)
    .enableNavigationControls(true);

// Tooltip functions
function showNodeTooltip(node) {
    const config = NODE_TYPE_CONFIG[node.nodeType] || { color: '#64748b', icon: 'circle', label: 'Node' };

    tooltip.classList.add('visible', 'node-tooltip');
    tooltip.classList.remove('edge-tooltip');

    // For characters, use tier-based color
    let nodeColor = config.color;
    if (node.nodeType === 'character' && node.tier) {
        const tierConfig = TIER_CONFIG[node.tier];
        if (tierConfig) nodeColor = tierConfig.color;
    }

    // Set the node color for CSS styling
    tooltip.style.setProperty('--node-color', nodeColor);
    tooltip.style.setProperty('--edge-color', '');

    // Update icon
    tooltipNodeIcon.innerHTML = `<i data-lucide="${config.icon}" class="w-5 h-5"></i>`;

    // Update content - add tier badge for characters
    let typeLabel = config.label;
    if (node.nodeType === 'character' && node.tier) {
        const tierConfig = TIER_CONFIG[node.tier];
        if (tierConfig) {
            typeLabel = `${tierConfig.icon} ${tierConfig.label}`;
        }
    }
    tooltipNodeType.textContent = typeLabel;
    tooltipNodeTitle.textContent = node.fullTitle || node.label;

    // Episode context or tier stats for characters
    if (node.nodeType === 'character' && node.episodeCount) {
        tooltipNodeEpisode.textContent = `${node.episodeCount} episodes, ${node.relationshipCount || 0} relationships`;
    } else {
        tooltipNodeEpisode.textContent = node.episode || '';
    }

    // Update link
    if (node.url) {
        tooltipNodeLink.href = node.url;
        tooltipNodeLink.style.display = 'flex';
        tooltipNodeLinkText.textContent = `View ${config.label.toLowerCase()}`;
    } else {
        tooltipNodeLink.style.display = 'none';
    }

    // Position and render
    positionTooltip();
    lucide.createIcons();
}

function showEdgeTooltip(link) {
    const config = CONNECTION_CONFIG[link.type] || { color: '#64748b', icon: 'link', label: link.type };

    tooltip.classList.add('visible', 'edge-tooltip');
    tooltip.classList.remove('node-tooltip');
    tooltip.style.setProperty('--edge-color', config.color);
    tooltip.style.setProperty('--conn-color', config.color);
    tooltip.style.setProperty('--node-color', '');

    tooltipEdgeType.innerHTML = `<i data-lucide="${config.icon}" class="w-3.5 h-3.5"></i> ${config.label}`;
    tooltipEdgeDescription.textContent = link.description ? `"${link.description}"` : 'No description available';

    // Get node labels (handle both string IDs and object references)
    const sourceNode = typeof link.source === 'object' ? link.source : nodeMap.get(link.source);
    const targetNode = typeof link.target === 'object' ? link.target : nodeMap.get(link.target);

    tooltipEdgeFrom.textContent = sourceNode?.label || link.source;
    tooltipEdgeTo.textContent = targetNode?.label || link.target;
    tooltipEdgeStrength.textContent = `Strength: ${link.strength || 'medium'}`;

    // Update link
    if (link.pk) {
        tooltipEdgeLink.href = `/connections/${link.pk}/`;
        tooltipEdgeLink.style.display = 'flex';
    } else {
        tooltipEdgeLink.style.display = 'none';
    }

    // Position and render
    positionTooltip();
    lucide.createIcons();
}

function hideTooltip() {
    tooltip.classList.remove('visible', 'node-tooltip', 'edge-tooltip');
}

function scheduleHideTooltip(delay = 200) {
    // Don't hide if mouse is over tooltip
    if (isMouseOverTooltip) return;

    // Clear any existing timeout
    if (hideTooltipTimeout) {
        clearTimeout(hideTooltipTimeout);
    }

    // Schedule hide with delay
    hideTooltipTimeout = setTimeout(() => {
        if (!isMouseOverTooltip) {
            hideTooltip();
        }
        hideTooltipTimeout = null;
    }, delay);
}

function cancelHideTooltip() {
    if (hideTooltipTimeout) {
        clearTimeout(hideTooltipTimeout);
        hideTooltipTimeout = null;
    }
}

// Control button handlers
document.getElementById('btn-zoom-in').addEventListener('click', () => {
    const pos = Graph.cameraPosition();
    const distance = Math.sqrt(pos.x*pos.x + pos.y*pos.y + pos.z*pos.z);
    const factor = 0.7;
    Graph.cameraPosition({
        x: pos.x * factor,
        y: pos.y * factor,
        z: pos.z * factor
    }, null, 300);
});

document.getElementById('btn-zoom-out').addEventListener('click', () => {
    const pos = Graph.cameraPosition();
    const distance = Math.sqrt(pos.x*pos.x + pos.y*pos.y + pos.z*pos.z);
    const factor = 1.4;
    Graph.cameraPosition({
        x: pos.x * factor,
        y: pos.y * factor,
        z: pos.z * factor
    }, null, 300);
});

document.getElementById('btn-center').addEventListener('click', () => {
    Graph.zoomToFit(400, 50);
});

document.getElementById('btn-pause').addEventListener('click', function() {
    isPaused = !isPaused;
    const icon = this.querySelector('i');

    if (isPaused) {
        Graph.pauseAnimation();
        this.classList.add('active');
        icon.setAttribute('data-lucide', 'play');
    } else {
        Graph.resumeAnimation();
        this.classList.remove('active');
        icon.setAttribute('data-lucide', 'pause');
    }
    lucide.createIcons();
});

document.getElementById('btn-toggle-2d').addEventListener('click', function() {
    is3D = !is3D;

    if (is3D) {
        // Switch to 3D mode
        Graph.numDimensions(3);
        this.classList.remove('active');
        this.innerHTML = '<i data-lucide="box" class="w-5 h-5"></i>';

        // Restore 3D-appropriate settings
        if (!performanceMode) {
            Graph
                .nodeResolution(16)
                .linkCurvature(0.1);
        }
    } else {
        // Switch to 2D mode - much faster!
        Graph.numDimensions(2);
        this.classList.add('active');
        this.innerHTML = '<i data-lucide="square" class="w-5 h-5"></i>';

        // Apply 2D optimizations (flat view needs less detail)
        Graph
            .nodeResolution(8)  // Lower res fine for 2D
            .linkCurvature(0);   // Straight lines in 2D

        // Reset camera to top-down view
        setTimeout(() => {
            Graph.cameraPosition({ x: 0, y: 0, z: 500 }, { x: 0, y: 0, z: 0 }, 500);
        }, 100);
    }

    lucide.createIcons();
    console.log(`Switched to ${is3D ? '3D' : '2D'} mode`);
});

// Fullscreen toggle
function toggleFullscreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
    } else {
        document.exitFullscreen();
    }
}

// Hide loading overlay and fit view after initial layout
Graph.onEngineStop(() => {
    loadingOverlay.classList.add('hidden');
    // Auto-fit after simulation settles
    setTimeout(() => Graph.zoomToFit(400, 50), 100);
});

// Fallback: hide loading after timeout even if simulation doesn't stop
setTimeout(() => {
    loadingOverlay.classList.add('hidden');
}, 3000);

// Handle window resize
window.addEventListener('resize', () => {
    Graph.width(container.clientWidth);
    Graph.height(container.clientHeight);
});

// Initial camera position adjustment for better view
setTimeout(() => {
    Graph.zoomToFit(600, 100);
}, 500);

// Node type toggle handlers
document.querySelectorAll('.node-toggle').forEach(btn => {
    btn.addEventListener('click', function() {
        const nodeType = this.dataset.type;

        if (visibleNodeTypes.has(nodeType)) {
            visibleNodeTypes.delete(nodeType);
            this.classList.remove('active');
        } else {
            visibleNodeTypes.add(nodeType);
            this.classList.add('active');
        }

        // Update graph with filtered data
        const newData = getFilteredGraphData();
        Graph.graphData(newData);
        updateStats();

        // Re-init icons
        lucide.createIcons();
    });
});

// Performance mode toggle
let performanceMode = forceGraphData.nodes.length > 300;  // Auto-enable for large graphs
const perfBtn = document.getElementById('btn-performance');

function applyPerformanceMode(enabled) {
    performanceMode = enabled;
    perfBtn.classList.toggle('active', enabled);

    if (enabled) {
        // Ultra performance settings
        Graph
            .nodeResolution(6)
            .linkOpacity(0.4)
            .linkWidth(0.5)
            .linkDirectionalArrowLength(0)
            .linkDirectionalParticles(0)  // Disable particles
            .linkCurvature(0)
            .d3AlphaDecay(0.06)
            .d3VelocityDecay(0.5);
    } else {
        // Quality settings with particles
        Graph
            .nodeResolution(16)
            .linkOpacity(0.7)
            .linkWidth(link => {
                switch(link.strength) {
                    case 'strong': return 2;
                    case 'medium': return 1.2;
                    default: return 0.6;
                }
            })
            .linkDirectionalArrowLength(4)
            .linkDirectionalParticles(link => link.strength === 'strong' ? 2 : 1)
            .linkCurvature(0.1)
            .d3AlphaDecay(0.02)
            .d3VelocityDecay(0.3);
    }
}

// Auto-enable performance mode for large graphs
if (performanceMode) {
    applyPerformanceMode(true);
    console.log('Performance mode auto-enabled for large graph');
}

// Auto-switch to 2D for very large graphs (massive performance boost)
const autoSwitch2D = allNodes.length > 500 || allLinks.length > 2000;
if (autoSwitch2D) {
    setTimeout(() => {
        const toggle2dBtn = document.getElementById('btn-toggle-2d');
        is3D = false;
        Graph.numDimensions(2);
        toggle2dBtn.classList.add('active');
        toggle2dBtn.innerHTML = '<i data-lucide="square" class="w-5 h-5"></i>';
        Graph.nodeResolution(6).linkCurvature(0);
        lucide.createIcons();
        console.log('2D mode auto-enabled for very large graph');
    }, 100);
}

perfBtn.addEventListener('click', () => {
    applyPerformanceMode(!performanceMode);
    lucide.createIcons();
});

// Log performance stats
console.log(`Graph stats: ${allNodes.length} nodes, ${allLinks.length} edges`);
console.log(`Performance mode: ${performanceMode ? 'ON' : 'OFF'}`);
console.log(`Auto 2D: ${autoSwitch2D ? 'YES' : 'NO'}`);
</script>
{% endblock %}
